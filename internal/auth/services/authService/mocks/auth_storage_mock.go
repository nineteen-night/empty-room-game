// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/nineteen-night/empty-room-game/internal/auth/models"
	mock "github.com/stretchr/testify/mock"
)

// AuthStorage is an autogenerated mock type for the AuthStorage type
type AuthStorage struct {
	mock.Mock
}

type AuthStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *AuthStorage) EXPECT() *AuthStorage_Expecter {
	return &AuthStorage_Expecter{mock: &_m.Mock}
}

// CheckPasswordHash provides a mock function with given fields: password, hash
func (_m *AuthStorage) CheckPasswordHash(password string, hash string) bool {
	ret := _m.Called(password, hash)

	if len(ret) == 0 {
		panic("no return value specified for CheckPasswordHash")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(password, hash)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AuthStorage_CheckPasswordHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckPasswordHash'
type AuthStorage_CheckPasswordHash_Call struct {
	*mock.Call
}

// CheckPasswordHash is a helper method to define mock.On call
//   - password string
//   - hash string
func (_e *AuthStorage_Expecter) CheckPasswordHash(password interface{}, hash interface{}) *AuthStorage_CheckPasswordHash_Call {
	return &AuthStorage_CheckPasswordHash_Call{Call: _e.mock.On("CheckPasswordHash", password, hash)}
}

func (_c *AuthStorage_CheckPasswordHash_Call) Run(run func(password string, hash string)) *AuthStorage_CheckPasswordHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *AuthStorage_CheckPasswordHash_Call) Return(_a0 bool) *AuthStorage_CheckPasswordHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AuthStorage_CheckPasswordHash_Call) RunAndReturn(run func(string, string) bool) *AuthStorage_CheckPasswordHash_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePartnership provides a mock function with given fields: ctx, user1ID, user2ID
func (_m *AuthStorage) CreatePartnership(ctx context.Context, user1ID string, user2ID string) (string, error) {
	ret := _m.Called(ctx, user1ID, user2ID)

	if len(ret) == 0 {
		panic("no return value specified for CreatePartnership")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, user1ID, user2ID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, user1ID, user2ID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, user1ID, user2ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_CreatePartnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePartnership'
type AuthStorage_CreatePartnership_Call struct {
	*mock.Call
}

// CreatePartnership is a helper method to define mock.On call
//   - ctx context.Context
//   - user1ID string
//   - user2ID string
func (_e *AuthStorage_Expecter) CreatePartnership(ctx interface{}, user1ID interface{}, user2ID interface{}) *AuthStorage_CreatePartnership_Call {
	return &AuthStorage_CreatePartnership_Call{Call: _e.mock.On("CreatePartnership", ctx, user1ID, user2ID)}
}

func (_c *AuthStorage_CreatePartnership_Call) Run(run func(ctx context.Context, user1ID string, user2ID string)) *AuthStorage_CreatePartnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *AuthStorage_CreatePartnership_Call) Return(_a0 string, _a1 error) *AuthStorage_CreatePartnership_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_CreatePartnership_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *AuthStorage_CreatePartnership_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *AuthStorage) CreateUser(ctx context.Context, user *models.User) (string, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) (string, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.User) string); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.User) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type AuthStorage_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *models.User
func (_e *AuthStorage_Expecter) CreateUser(ctx interface{}, user interface{}) *AuthStorage_CreateUser_Call {
	return &AuthStorage_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *AuthStorage_CreateUser_Call) Run(run func(ctx context.Context, user *models.User)) *AuthStorage_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.User))
	})
	return _c
}

func (_c *AuthStorage_CreateUser_Call) Return(_a0 string, _a1 error) *AuthStorage_CreateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_CreateUser_Call) RunAndReturn(run func(context.Context, *models.User) (string, error)) *AuthStorage_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartnershipBetweenUsers provides a mock function with given fields: ctx, user1ID, user2ID
func (_m *AuthStorage) GetPartnershipBetweenUsers(ctx context.Context, user1ID string, user2ID string) (*models.Partnership, error) {
	ret := _m.Called(ctx, user1ID, user2ID)

	if len(ret) == 0 {
		panic("no return value specified for GetPartnershipBetweenUsers")
	}

	var r0 *models.Partnership
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*models.Partnership, error)); ok {
		return rf(ctx, user1ID, user2ID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *models.Partnership); ok {
		r0 = rf(ctx, user1ID, user2ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Partnership)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, user1ID, user2ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_GetPartnershipBetweenUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartnershipBetweenUsers'
type AuthStorage_GetPartnershipBetweenUsers_Call struct {
	*mock.Call
}

// GetPartnershipBetweenUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - user1ID string
//   - user2ID string
func (_e *AuthStorage_Expecter) GetPartnershipBetweenUsers(ctx interface{}, user1ID interface{}, user2ID interface{}) *AuthStorage_GetPartnershipBetweenUsers_Call {
	return &AuthStorage_GetPartnershipBetweenUsers_Call{Call: _e.mock.On("GetPartnershipBetweenUsers", ctx, user1ID, user2ID)}
}

func (_c *AuthStorage_GetPartnershipBetweenUsers_Call) Run(run func(ctx context.Context, user1ID string, user2ID string)) *AuthStorage_GetPartnershipBetweenUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *AuthStorage_GetPartnershipBetweenUsers_Call) Return(_a0 *models.Partnership, _a1 error) *AuthStorage_GetPartnershipBetweenUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_GetPartnershipBetweenUsers_Call) RunAndReturn(run func(context.Context, string, string) (*models.Partnership, error)) *AuthStorage_GetPartnershipBetweenUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetPartnershipByID provides a mock function with given fields: ctx, partnershipID
func (_m *AuthStorage) GetPartnershipByID(ctx context.Context, partnershipID string) (*models.Partnership, error) {
	ret := _m.Called(ctx, partnershipID)

	if len(ret) == 0 {
		panic("no return value specified for GetPartnershipByID")
	}

	var r0 *models.Partnership
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.Partnership, error)); ok {
		return rf(ctx, partnershipID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.Partnership); ok {
		r0 = rf(ctx, partnershipID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.Partnership)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, partnershipID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_GetPartnershipByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPartnershipByID'
type AuthStorage_GetPartnershipByID_Call struct {
	*mock.Call
}

// GetPartnershipByID is a helper method to define mock.On call
//   - ctx context.Context
//   - partnershipID string
func (_e *AuthStorage_Expecter) GetPartnershipByID(ctx interface{}, partnershipID interface{}) *AuthStorage_GetPartnershipByID_Call {
	return &AuthStorage_GetPartnershipByID_Call{Call: _e.mock.On("GetPartnershipByID", ctx, partnershipID)}
}

func (_c *AuthStorage_GetPartnershipByID_Call) Run(run func(ctx context.Context, partnershipID string)) *AuthStorage_GetPartnershipByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *AuthStorage_GetPartnershipByID_Call) Return(_a0 *models.Partnership, _a1 error) *AuthStorage_GetPartnershipByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_GetPartnershipByID_Call) RunAndReturn(run func(context.Context, string) (*models.Partnership, error)) *AuthStorage_GetPartnershipByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByID provides a mock function with given fields: ctx, userID
func (_m *AuthStorage) GetUserByID(ctx context.Context, userID string) (*models.User, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByID")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_GetUserByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByID'
type AuthStorage_GetUserByID_Call struct {
	*mock.Call
}

// GetUserByID is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *AuthStorage_Expecter) GetUserByID(ctx interface{}, userID interface{}) *AuthStorage_GetUserByID_Call {
	return &AuthStorage_GetUserByID_Call{Call: _e.mock.On("GetUserByID", ctx, userID)}
}

func (_c *AuthStorage_GetUserByID_Call) Run(run func(ctx context.Context, userID string)) *AuthStorage_GetUserByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *AuthStorage_GetUserByID_Call) Return(_a0 *models.User, _a1 error) *AuthStorage_GetUserByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_GetUserByID_Call) RunAndReturn(run func(context.Context, string) (*models.User, error)) *AuthStorage_GetUserByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByUsername provides a mock function with given fields: ctx, username
func (_m *AuthStorage) GetUserByUsername(ctx context.Context, username string) (*models.User, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByUsername")
	}

	var r0 *models.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.User, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.User); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_GetUserByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByUsername'
type AuthStorage_GetUserByUsername_Call struct {
	*mock.Call
}

// GetUserByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *AuthStorage_Expecter) GetUserByUsername(ctx interface{}, username interface{}) *AuthStorage_GetUserByUsername_Call {
	return &AuthStorage_GetUserByUsername_Call{Call: _e.mock.On("GetUserByUsername", ctx, username)}
}

func (_c *AuthStorage_GetUserByUsername_Call) Run(run func(ctx context.Context, username string)) *AuthStorage_GetUserByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *AuthStorage_GetUserByUsername_Call) Return(_a0 *models.User, _a1 error) *AuthStorage_GetUserByUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_GetUserByUsername_Call) RunAndReturn(run func(context.Context, string) (*models.User, error)) *AuthStorage_GetUserByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// HashPassword provides a mock function with given fields: password
func (_m *AuthStorage) HashPassword(password string) (string, error) {
	ret := _m.Called(password)

	if len(ret) == 0 {
		panic("no return value specified for HashPassword")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(password)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(password)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(password)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_HashPassword_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashPassword'
type AuthStorage_HashPassword_Call struct {
	*mock.Call
}

// HashPassword is a helper method to define mock.On call
//   - password string
func (_e *AuthStorage_Expecter) HashPassword(password interface{}) *AuthStorage_HashPassword_Call {
	return &AuthStorage_HashPassword_Call{Call: _e.mock.On("HashPassword", password)}
}

func (_c *AuthStorage_HashPassword_Call) Run(run func(password string)) *AuthStorage_HashPassword_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *AuthStorage_HashPassword_Call) Return(_a0 string, _a1 error) *AuthStorage_HashPassword_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_HashPassword_Call) RunAndReturn(run func(string) (string, error)) *AuthStorage_HashPassword_Call {
	_c.Call.Return(run)
	return _c
}

// TerminatePartnership provides a mock function with given fields: ctx, partnershipID
func (_m *AuthStorage) TerminatePartnership(ctx context.Context, partnershipID string) error {
	ret := _m.Called(ctx, partnershipID)

	if len(ret) == 0 {
		panic("no return value specified for TerminatePartnership")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, partnershipID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AuthStorage_TerminatePartnership_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminatePartnership'
type AuthStorage_TerminatePartnership_Call struct {
	*mock.Call
}

// TerminatePartnership is a helper method to define mock.On call
//   - ctx context.Context
//   - partnershipID string
func (_e *AuthStorage_Expecter) TerminatePartnership(ctx interface{}, partnershipID interface{}) *AuthStorage_TerminatePartnership_Call {
	return &AuthStorage_TerminatePartnership_Call{Call: _e.mock.On("TerminatePartnership", ctx, partnershipID)}
}

func (_c *AuthStorage_TerminatePartnership_Call) Run(run func(ctx context.Context, partnershipID string)) *AuthStorage_TerminatePartnership_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *AuthStorage_TerminatePartnership_Call) Return(_a0 error) *AuthStorage_TerminatePartnership_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *AuthStorage_TerminatePartnership_Call) RunAndReturn(run func(context.Context, string) error) *AuthStorage_TerminatePartnership_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserMaxRoom provides a mock function with given fields: ctx, userID, roomNumber
func (_m *AuthStorage) UpdateUserMaxRoom(ctx context.Context, userID string, roomNumber int32) (bool, error) {
	ret := _m.Called(ctx, userID, roomNumber)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserMaxRoom")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int32) (bool, error)); ok {
		return rf(ctx, userID, roomNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int32) bool); ok {
		r0 = rf(ctx, userID, roomNumber)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int32) error); ok {
		r1 = rf(ctx, userID, roomNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AuthStorage_UpdateUserMaxRoom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserMaxRoom'
type AuthStorage_UpdateUserMaxRoom_Call struct {
	*mock.Call
}

// UpdateUserMaxRoom is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - roomNumber int32
func (_e *AuthStorage_Expecter) UpdateUserMaxRoom(ctx interface{}, userID interface{}, roomNumber interface{}) *AuthStorage_UpdateUserMaxRoom_Call {
	return &AuthStorage_UpdateUserMaxRoom_Call{Call: _e.mock.On("UpdateUserMaxRoom", ctx, userID, roomNumber)}
}

func (_c *AuthStorage_UpdateUserMaxRoom_Call) Run(run func(ctx context.Context, userID string, roomNumber int32)) *AuthStorage_UpdateUserMaxRoom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int32))
	})
	return _c
}

func (_c *AuthStorage_UpdateUserMaxRoom_Call) Return(_a0 bool, _a1 error) *AuthStorage_UpdateUserMaxRoom_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AuthStorage_UpdateUserMaxRoom_Call) RunAndReturn(run func(context.Context, string, int32) (bool, error)) *AuthStorage_UpdateUserMaxRoom_Call {
	_c.Call.Return(run)
	return _c
}

// NewAuthStorage creates a new instance of AuthStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAuthStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *AuthStorage {
	mock := &AuthStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
